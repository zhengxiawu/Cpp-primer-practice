# C++ primer 第六章 函数 

标签（空格分隔）： C++ 编程

---

### 函数基础

一个函数包括以下几个部分：返回类型，函数名字，由0个或多个形参。
当我们调用函数的时候，其实首先是吧控制权利交给了具体的函数，然后初始化它的形参，定义需要的变量，然后调用具体的实参。

>练习6.1 形参指的是我们在定义一个函数的时候，具体的形式化的参数，不用来做使用，只是一项声明，我们需要用这个参数。而实参代表了我们具体使用的参数。
>练习6.2 (a) 声明返回Int但是返回了string  (b)没有生命返回值，加一个void (c) 两个形参不能重名。 (d) 必须要有花括号。

---

局部对象：
名字有作用于，对象有生命周期。

*  名字的作用域是程序文本的一部分，名字在其中可见
*  对象的生命周期是指程序执行中一个对象存在的时间。

函数体内部定义的变量都叫做局部变量。

函数体外部的变量存在于整个执行过程当中，当程序结束才会被销毁。局部变量的生命周期依赖于定义方式。

自动对象：我们把只存在与执行期间的对象称之为自动对象。当块执行结束之后，创建的对象就变成未定义。比如说形参。如果没有定义，进行默认初始化。

局部静态对象：我们可以在函数体内部加上一个static变量，让这个参数在函数第一次执行就被初始化，直到最后才被销毁。

>练习6.6具体的来说，形参在上面的题目中已经说明。局部变量的作用仅仅在函数体的内部，而局部静态对象对于整个的程序来说。


函数声明：我们可以只声明不定义，其实声明的时候，只用名字就可以。可以不包括函数体，也就是不包括形参。但是在一般声明当中，加上形参方便进行函数的理解。

### 参数传递

函数在每一次调用的时候，都会创建一个形参，用具体的实参进行初始化。

当初始化一个非引用的变量的时候，我们把初始值传递给了里面的变量，也就是**传值**，但是，当我们传递指针的时候，我们传递的也是这个指针的拷贝，但是我们可以通过这个指针，来对具体的变量进行访问。

我们可以在具体的函数里面传递引用，来对于具体的函数进行修改具体的变量的时候，我们可以传递引用，也是**引用传递**

这样有一个好处就是，我们避免了拷贝，也就是说，在很多时候很多类不支持拷贝，比如io或者类太长的时候。

我们也可以使用引用参数，来做多个输出

>练习6.12：我觉得还是使用指针方便，不用初始化进行值。
>练习6.13 第一个是传递的是这个 类型的值，另外一个是传递这个类型的引用。
>练习6.14 比如我们需要交换两个变量的值，这个时候就需要用到具体的类型。比如说我们计算一个string类型有多少个char c 这个时候，传值就可以了。
>练习 6.15 首先第一个只想string 常量的引用指的是我们不可以修改它的值。**拷贝s的话可能需要很大的空间，所以我们使用常量引用**而我们需要具体修改occur的值，所以使用了普通的引用。c的话只是一个很小的char所以我们使用值传递就行了。

**const形参和实参**：

当是顶层const的时候，不可以传递非const变量，因为会把他初始化掉。

当我们在使用一个具体很长的变量的时候，我们可以定义const string &s 来定义常量引用，这样只是传递一个s也是可以的。尽量这么使用，好处有两个，第一个是避免了拷贝，第二个是不会任意修改。

>练习 6.16我觉得局限性的地方是，当调用它的函数输入的是const string &s的时候，这个时候就无法调用，并且可能会修改到s的值。具体的话可以吧string &s修改成 const string &s
>练习6.18 bool compare(const matrix &m1,const matrix &m2)   vector<int>::iterator change_val(int a,vector<int>::iterator)
>练习6.19 （a）不合法，规定输入只有一个 (b)合法 (c) 合法，可以进行转换 (d)合法，可以进行转换，但是会损失精度
>练习6.20 当我们要使用这个形参，但是形参在具体使用的时候，不允许修改这个值，这个时候，就是常量引用。


**数组形参**：

数组无法被拷贝走，所以我们在具体传递数组的时候，应该传递的是数组的指针。

下面这三种方式其实是等价的

void print(const int*)
void print(const int[])
void print(const int[10])

既可以传递进去指向int的指针也可以传递指向数组的指针。

一般传递数组指针的时候，我们并不知道具体的长度，所以管理指针形参有三种常用的技术：

* **使用标记来指定数组长度**：比如说一般c风格的字符串，就会又一个默认的空字符
* **使用标准库规范**：我们可以传递进去指向数组头和尾部的指针。
* 显示的传递一个数组的大小

传递多维度的数组的话，必须要传递一个真正只想数组的指针 比如 (*matrix)[10]

>练习6.24 打印一个固定长度为10的数组，但是会有风险，所以可以分开来传递。

含有可变形参的函数：

有时候我们无法预知要使用多少个参数，我们可以使用两种办法，第一种是initializer_list 的标准类型库。第二种就是 可变参数模板

如果说，函数的实参数量未知，我们可以使用**initializer_list** 类型的形参

initializer_list和vector有点类似。有点不一样的是，initialzer_list里面永远是常量，我们无法修改里面的值。

>练习 6.28 是指向const string的引用。
>练习 6.29 不应该，因为initializer_list 是一个不允许改变的常量。

### 函数的返回值

* 无返回值：函数可以没有返回值，也就是可以不用return，但是，如果需要return的话，必须返回一个void函数

* 有返回值：必须与声明的时候类型相同，或者可以隐式的转换一下。 返回的值用于初始化调用点的临时变量，也可以返回一个引用。但是，在定义返回值为引用的时候，我们需要注意的是，不要返回指向局部变量的引用或者指针，因为函数执行完之后，会销毁内存。所以使用的话，会指向一个不存在的变量。 
* 当返回的是引用的时候，函数调用得到一个左值。其他类型返回右值。

* C++11新的规定，可以返回一个 花括号括起来的列表

>练习6.30 报告定义的是bool返回了一个空
>练习6.31 当引用的是函数内部的变量的时候，引用无效。当不希望修改对象的时候，返回常量引用。
>练习6.32 合法，首先函数返回一个函数对应的指针，然后赋值给相应的变量
>练习6.32 当输入负数的时候，会陷入死循环。
>练习 6.35 我们需要先让Val自减，然后再进行赋值。

当我们需要返回数组指针的时候，我们可以需用这样的方式来返回 

Type(*functioon(parameter_list))[dimension]
 
 上面的方式比较繁琐，我们也可以使用别名
 
 typedef int arrT[10]
 
 using arrT=int[10]
 arrT* func(int i);
 
 我们也可以使用尾置返回类型
 
 auto func(int i)->int(*)[10]
 
 也可以使用decltype
 
 int odd[] = {1,2,3,4,5}
 
 decltype(odd) *arrPtr(int i)
 
 >练习 6.36 string (*function(int i))[10]
 >练习 6.37  typedef string arrT[10] using arrT=string[10]
 >练习6.38 decltype(odd) &arrPtr
 
 ---
 
### 函数的重载
 
 
 如果一个作用域内部的函数名字相同，但是形参列表不一样，我们称之为重载。 编译器会根据形参来对具体的函数进行调用。
 
 对于顶层const来说，在函数重载当中，并不做区分，但是对于指针和引用来说，底层const是可以被区分的。
 
 对于const来说，假如一个函数是用const引用来进行调用的，我们知道的是，我们传入一个正常的变量的时候，会自动转成一个const，但是返回也是一个const，这个时候，我们可以使用const_cast来抛弃我们的具体的const
 
 >练习 6.39 (a)非法，因为const可以相互转换，在重载当中不区分。 (b) 非法 因为参数都一样 (c)合法，第二个输入double变量。
 
 我们需要注意的是，当我们在一个作用于外部声明了一些列重载函数，在内部又重新声明，外部的声明会被覆盖掉。
 
 ---
 
### 特殊用途的语言特性

默认实参：

* 我们可以在声明函数的时候，给形参配上默认的实参，需要注意的是，一旦某个形参被赋予了实参，后面的形参都应该被赋予默认值。
* 调用的时候，我们默认省略掉这个值就好了。但是需要注意的是，在调用后面的默认形参必须给前面的形参赋值。
* 我们可以在调用之前声明默认形参。我们可以多次声明默认形参，但是需要注意的是，在给定的作用域当中，一个形参只能被赋予一次默认形参，非则就是重复声明了。
* 我们需要注意的是，当我们使用局部变量的时候，默认形参并不会发生改变，会使用全局之前定义好的实参来作为默认值。

>练习 6.40 (b)非法的，因为当一个变量被赋予默认实参之后，后面的变量都应该被赋予。
>练习 6.41 (a)非法，第一个必须被赋值 (b)合法 (c)合法，但是会进行类型转换，违反了初衷。
 
 一般来说一些比较简单的函数，我们可以加上inline关键字，把它定义为内联函数，就是在表达式当中内联的展开。这样可以节省开支。
 
 >练习6.43 （a）放到头文件中，因为是一个大家都需要的函数，并且是内联函数 (b)是一个函数的声明，应该放在头文件当中去
 >练习 6.46 不行，因为isshorter需要经常调用，不能一直返回一个常量。
 
 调试帮助：
 
 * 我们可以使用**assert**来对错误信息进行处理 ，当assert里面的内容为真的时候，什么也不错，当变量为假的时候，停止程序。并且需要include cassert 
 * 我们可以使用NDUBUG来打开或者关闭具体的调试

>练习 6.48不合理 因为assert会一直为真

### 函数匹配

* 候选函数： 一般在定义重载函数的时候，调用对应的重载函数集。 具备两个特征：第一，与被调用的函数同名。第二，声明在调用点可见。
* 可行函数：主要考察本次调用提供的实参，从候选的函数当中选出可以被这组实参的调用的函数。也具有两个特征，第一本次调用提供的实参数量相同，第二是对应的形参类型相同。
* 寻找最佳匹配：实参类型与形参类型越接近，那么匹配的越好。
* 当有多个最佳匹配的时候，会因为这个调用具有二义性，而进行否决

>练习 6.49 如上
>练习 6.50 （a）不合法，会因为二义性而进行否决 (b) 最佳匹配 f(int) (c)最佳匹配 f(int,int) (d)最佳匹配 f(double,double)

>练习 6.52 (a)>(b)
>练习 6.53又影响，会产生二义性错误。

### 函数指针

* 我们可以使用 (*pf)来代替原来的函数名，来作为函数指针。
* 我们不需要解操作可以通过指针来对函数进行直接的调用
* 指针可以指向空，但是在指向别的指针的时候，实参类型以及对应的返回类型必须是匹配
* 当有函数的重载的时候，指针在定义的时候，要求必须精确匹配。
* 可以使用typedef来定义指向函数的指针