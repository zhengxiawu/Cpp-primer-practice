# 第二章 变量和基本类型

标签（空格分隔）： C++ 编程

---

###基本内置类型

---

>我们可以访问的可以寻址的最小内存块称为“字节”，一般一个字节(byte)为8比特(bit)一般来说，一个字(word)为32位

具体数值类型(int float long longlong)以及字符类型(char)都可以分为有符号无符号，但是char这个类型具体定义可以是有符号也可以是无符号，**具体根据不同的编译器来决定符号类型**

>练习2.1 int long longlong short的不同主要是表达的数据不同，精度不同以及长度不同。无符号与有符号主要的差别在于表达的区间不同 float 与 double主要是精度不同。
>练习2.2根据他们需要的精度，我觉得float应该就足够了


* 当0赋值给布尔值，自动变成false，否则变为 true
* 当true赋值给非布尔类型，变为1 false 为0
* float赋值给int 保留浮点数小数之前的部分。
* 整数赋值给浮点数时，小数部分标记为0，超过容量可能损失精度
* 赋值给无符号数超过范围的值，具体的值对于整个类型取模后的余数，比如-1复制给unsigned char结果为255
* 当赋值有符号数超过范围的时候，那么这个值就是未定义的。

**当一个算术表达式当中既有有符号的数，也有无符号的数，那么具体的数值会先转换成无符号的**

一个形如42 或者 'a'这样一看就知道类型的就是字面值。

**''里面表达的就是一个字符而""里面表达的就是一个字符串，所有字符串后面都会跟一个**

>练习2.5:
>(a)'a'就是一个char L'a'是一个wchar_t "a"是一个字符串 L"a"是一个宽字符串
>(b)10是一个带符号的int 10u是一个无符号的int 10L是一个long类型 10uL是一个无符号但是long类型的 012是八进制的12 oxC是一个十六进制的C
>(c)3.14是一个double 3.14f是一个float 3.14L是一个Long类型的3
>(d)10.是一个double类型的10e-2是一个10.00的double

> 练习2.6八进制和十进制的区别

### 变量

**在C++中，一般来说，变量就是对象**

**对象是指一块能够存储数据并且具有某种类型的内存空间**

**初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来代替它**

列表初始化，在C++当中，可以使用类似于int a{0}来进行列表初始化，当使用列表初始化初始值有丢失信息的危险，编译器会报错。

>练习2.9 (b)错误，因为列表初始化产生了信息丢失，所以导致编译器报错。

>练习2.10 global_int 是全局变量，所以被默认定义为0 local_int是局部变量，不被初始化，如果拷贝，就是未定义。 local_str被定义为空

在C++中，我们可以把分离和定义区分开来。我们可以在具体的变量前面加上extern关键字来进行声明。需要注意的是，如果我们声明了一个变量，并且对它进行赋值，那么，我们的声明就会被抵消。

>练习 2.11 (a)定义 (b)定义 (c)声明

>练习2.12 (a)非法，因为关键字 (b) 合法 (c) 非法，只包含下划线 (d)非法，必须以字母开头 (e)合法

一个名字的作用域开始于名字的声明语句，以声明语句所在的作用域末端为结束。

作用域分为内层作用域以及外层作用域，在内层作用域定义与外层一样的变量，可以覆盖外层的变量，但是可以使用::来显示的访问外层变量

>练习2.13 j的值为42
>练习2.14 合法 输出100 45

### 复合类型

复合类型是指基于其他类型的类型。 这里主要介绍两种：引用和指针。

**C++11中多添加了一种右值引用**

引用是为对象起了另外一个别名。

**引用必须被初始化，否则会报错**

当使用引用的时候，会和一个对象的初始值绑定到一起。

>练习2.15 （a）合法 (b)不合法，因为引用必须为对象(c)合法（d）不合法。引用必须被初始化
>练习2.16（a）合法（b）合法（c）合法(d)合法
>练习2.17 输出 10 10

---

指针与引用相比有很多不一样的地方，第一，指针本身是一个对象，允许指针赋值和拷贝，而且一个指针可以在生命周期内可以指向多个**不同的对象**。第二，指针没有必要在定义的时候赋值。

**和引用一样，除了一些特殊的情况，引用和指针在定义和使用必须指向一样的对象**


指针的值一般有四种情况：

 * 指向一个对象
 * 指向紧邻对象空间所占空间的下一个位置
 * 空指针，没有指向任何对象。
 * 无效指针，除了上面之外的。
**在定义的时候，我们在变量前面加*来表示指针，在定义引用的时候，用&来定义引用，在其他条件下，*表示解引用符，可以通过指针来访问对象，&表示取地址**

---

void\*指针是一种特殊的指针，它可以存放任何类型的指针。但是它可以做的事情比较有限，我们只能把这个指针拿来比较，或者作为函数的输入输出，或者赋值给另外一个void\* 指针，因为我们无法确定指向的对象，所以不能用它访问对象。

>练习2.19 指针和引用最主要的区别是，指针是一个对象，而引用并不是。所以指针可以做很多工作，比如改变，设立空指针，等等，而引用都不行。
>练习2.20 初始化并定义i 初始化一个指针p1然后指向i 把i*i赋值给i
>练习2.21 （a）非法，因为i是int而指针是double (b)非法，不能直接给指针赋值为一个Int而必须是int的地址。(c)合法
>练习2.22 判断p是不是一个控制帧 判断p指向的对象是true or false
>练习2.23 利用nullptr判断是否属于ptr
>练习2.24 因为类型不同

对于一个变量应该从右往左读写，比如说int *&r ，距离变量最近的，对变量有最直接的影响，比如上面那个r就是一个引用，然后是一个指向指针的引用，并且这个指针指向int

>练习2.25 (a) ip是一个指向Int类型的额指针，i是一个int变量，r是一个指向i的引用 (b)i是一个int类型变量，ip是一个空指针(c)ip是一个未初始化的指针 ip2是一个未初始化的int变量

###const限定符

---

对于一个变量，当我们不希望它被改变，我们就使用const限定符。**const常量必须要被初始化**

首先，const对象仅仅在一个文件内，才是有效的，比如我们定义了一个const int a=1；编译器会找到所有对应的a，然后替代成1.但是我们也可以在多个文件当中共享一个const，这样的情况下，我们可以使用extern关键字，对于一个具体的变量进行 extern声明，但是并不去定义他，在具体文件定义的时候，也需要使用extern。

>练习2.26 （a）非法 const必须被初始化 (b)合法 （c）合法(d)非法sz是一个const常量，无法修改。

当定义好一个const常量之后，我们可以在上面绑定引用。**但是引用必须也是常量引用。**表示的是对const的引用。

**一般来说，引用的类型必须与其所引用的对象保持一直，但是也有例外，第一种例外就是在初始化常量引用的时候允许用任意表达式，只要这个表达式可以转换成常量对应的类型**

例如：

```C++
double dval = 3.14;
const int &ri = dval;
---
const int temp = dval;
const int &ri = temp;
```

上面这一段代码，因为double遇到了const int常量引用，所以编译器会产生一个临时变量，来把引用绑定到这个上面。

**也就是说，const引用可以引用一个非const的变量。**

这里记下来主要介绍两个概念，指向常量的指针，以及常量指针。

* 指向常量的指针，顾名思义就是这个指针指向了常量，和引用一样，必须要绑定一个const限定符。同时，和上面的思想一样，我们可以允许常量指针指向一个非常量。**可以这么想，指向常量的引用以及指针，并不是真正的就指向了常量，只是他们认为自己指向了常量，所以无法通过这些指针去改变具体的值。**
* const指针：值得是指针本身就是一个常量。也就是说，一旦这个指针被定义，就无法被改变，我们使用int *const 来定义一个const指针。

>练习2.27 

> * (a)非法，因为引用r引用了一个字面字符值常量，而r本身是一个对于int的引用。
> * (b) 合法 p2是一个常量指针，指向了一个i2的地址
> * (c) 合法 i是一个const r是一个指向const的常量引用
> * (d) p3既是一个指向常量的指针，同时自己也是一个指针常量。这就意味着，p3一直指向i2并且p3认为i2是一个常量 
> * (e) 合法，p1认为自己指向的是一个int常量 
> * (f) 非法 const没有引用
> * (g) 合法

>练习 2.28
> * (a)非法，cosnst指针必须被初始化
> * (b)非法，cosnst指针必须被初始化
> * (c)非法，cosnst int 必须被初始化
> * (d)非法，指向const int的cosnst指针必须被初始化
> * (e)合法

>练习2.29
>(a)合法，其他非法

正如前面说的，指针可以指向一个常量，也可以自己是一个常量指针。所以顶层const表示指针本身是一个常量，底层const表示指向的是一个常量。

**除了指针有这样的区分，其他的类型都是顶层const，另外，引用都是底层const**

>练习 2.30
```C++
const int v2 = 0;//顶层const
const int *p2 = &v2, *const p3 = &i;//p2底层const p3既是顶层也是底层 
```
>练习 2.31
>p1=p2非法，因为p2是一个指向const的指针，当p1也指向这个const之后，会改变当前的值。
>p1=p3非法，理由同上。

>练习2.33 把null改成nullptr

###处理类型

---

我们可以使用typedef的方式来定义类型别名。

* 比如可以使用typedef double wages 把double与wages等价起来。typedef wages base, \*p的话就是把 base = double p=double\* 。
* 在心的标准当中，我们可以使用using wages = double 来代替上面的语句。 
* 我们在进行改写的时候，往往会有意想不到的效果，当我们进行如下的改写的时候，typedef char *pstring 在这种情况下 const pstring cstr;**在这里 cstr 是一个指向char类型的指针常量，但是，当我们直接带入 const char * cstr 这样的情况下，cstr又是一个指向常量字符的指针，这一点要牢牢记住**

---

* auto类型的说明符主要是用来让编译器自动的分析我们所需要的类型。**auto在一个语句当中，只能代表一个类型**
* 但是，当我们指定auto后面跟一个引用的时候，原来的const特性又会保留下来。
* 当我们利用引用在赋值的时候，auto不是引用类型，而是具体引用的对象。 
* auto 一般会忽略掉顶层const，底层const会保留下来。当我们需要用顶层const的时候，我们需要另外加一个const关键字。

>练习 2.33 前面三个语句是正确的，后面三个语句可以执行但是是错误的。后面三个骑士都是指针，或者引用，直接赋值可以成功，但是不正确。

---

* decltype希望从表达式当中直接推断变量的类型，但是不想用该表达式的值去初始化。
* decltype两个括号之后，就代表的是引用。
* 注意一个情况 int i = 42,*p = &i; decltype(*p) c ;这个时候的c是引用，因为*p相当于int &

>练习 2.36
a int 4 ,b int 4, c int 4, d 对于a的引用 

>练习 2.37 ：a:int 3,b int 4, c int 3, d 对于a的引用3;

>练习2.38 decltype 与auto都是自动推断，一样的情况就是普通的情况
int a = 1 auto b = a 与 decltype(a) c 一样
但是当const的时候就不太一样，decltyoe就会保留下来，而auto不会。

###自定义数据结构

我们可以使用struct来自定义数据结构.


**程序员在定义头文件的时候，应该习惯性的加上头文件保护符 **
 

